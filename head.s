LATCH				= 11930				# 定时器初始计数值（10ms）
SCRN_SEL			= 0x18				# 屏幕显示内存段选择符
TSS0_SEL			= 0x20				# 任务0的TSS段选择符
LDT0_SEL			= 0x28				# 任务0的LDT段选择符
TSS1_SEL			= 0x30				# 任务1的TSS段选择符
LDT1_SEL			= 0x38				# 任务1的LDT段选择符
.text
startup_32:

# 15----------3|--0
#   		   |T R
#	描述符索引 |I P
#			   |  L
# -------------|---
		movl $0x10, %eax				# 0x10为GDT表索引为2的位置，权限位为0x00，也就是数据段，基地址为0x0
		mov %ax, %ds

# lss，若REG是16位的，则源操作数必须是32位的；
# 若REG是32位的，则源操作数必须是48位的。
# 将低位送REG，将高位送SS，REG不能是段寄存器
		lss init_stack, %esp			# 这里将SS也设为了0x10，参见后面的init_stack

# 上面的操作应该就是为了下面的两个call做DS和SS的准备
# 跳到现在这个新的位置之后，重新设置IDT和GDT
# 但实际上，可以沿用boot.s中的设置，这里进行设置是为了让程序更清晰，也与Linux的处理保持一致
		call setup_idt					# 设置IDT，所有中断都由默认中断处理程序处理
		call setup_gdt					# 设置GDT

		movl $0x10, %eax				# 改变GDT后，重新加载所有段寄存器
		mov %ax, %ds
		mov %ax, %es
		mov %ax, %fs
		mov %ax, %gs
		lss init_stack, %esp

# 设置8253定时器芯片
# 8253采用减1计数的方式
# 端口0~2分别对应计数器0~2，端口3是控制寄存器，端口地址在0x40 ~ 0x43

# 控制寄存器
# 7------0
# SSRRMMMB
# CCLL   C
# 1010210D
# --------
# SC 通道0 ~ 2，3不用
# RL 读写方式 0，计数器锁存；1，只读写低8位；2，只读写高8位；3，全16位
# M  计数方式 0 ~ 5，分别为“计数结束则中断”、“单脉冲发生器”、“速率波发生器”、“方波发生器”、“软件触发方式计数”、“硬件触发方式计数”
# BCD 0，计数值为二进制数；1，计数值为BCD编码的数

		movb $0x36, %al					# 通道0，全16位读写，计数方式3：“方波发生器”，二进制计数
		movl $0x43,	%edx				# 控制端口地址
		outb %al, %dx					# 端口输出

# 输出频率 = CLK频率 / 计数值 = 1.193MHz / 11930 = 1193000 / 11930 = 100Hz
# 所以，计数值如果设为11930，每隔10ms，就会收到一个时钟中断
		movl $LATCH, %eax				# $LATCH = 11930
		movl $0x40, %edx				# 计数器0的端口地址
		outb %al, %dx					# 全16位输出需分两次，先低后高
		movb %ah, %al
		outb %al, %dx
		
# 接下来设置时钟中断处理程序